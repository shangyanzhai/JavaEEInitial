关于锁的策略 2023-5-13
    读/写锁分离            共享锁（Share）/互斥锁（eXclusive）

            读操作         写操作
    读操作   没必要互斥     需要互斥
    写操作   需要互斥       需要互斥

    次数 of (读读)    远远大于  其他 3 种
        java.util.concurrent.locks.ReadWriteLock;//读锁
        java.util.concurrent.locks.ReentrantReadWriteLock;//写锁


    原子性操作 CAS
    boolean CAS(地址, 期望的值, 希望修改的值);

    int a = 10;
    CAS(&a, 10, 20);
    true: 修改成功，a 的值变成 20 了
    false: 修改失败, a 的值现在是多少？不知道。一定有其他线程参与修改了
           再次重试(基于概率不高的前提，常数次修改一定可以成功）

    原子对象
    java.util.concurrent.atomic.*;

    乐观 和 悲观
    悲观：判断 多线程 针对该共享资源的并发访问非常激烈，所以采用了保守的做法 —— 锁。
    乐观：判断 多线程 针对该共享资源的并发访问可能性不高，所以采用了激进的措施，不加锁。

    实现锁的方案 ：自旋锁 vs 互斥锁
    1. 互斥锁：加锁失败，立即放弃 CPU
    2. 自旋锁：加锁失败，尝试做做努力（跑几个空循环），再次尝试加锁

    公平锁（维护队列） vs 非公平锁（甩手掌柜）

    重入锁（可重复加锁） vs 不可重入锁（不可重复加锁）